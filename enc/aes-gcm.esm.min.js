async function z(t,r){if(r.length!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let e=await crypto.subtle.importKey("raw",r,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),n=crypto.getRandomValues(new Uint8Array(12)),a=await crypto.subtle.encrypt({name:"AES-GCM",iv:n,tagLength:128},e,t),o=new Uint8Array(a),s=new Uint8Array(n.length+o.length);return s.set(n,0),s.set(o,n.length),s}async function G(t,r){if(r.length!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let e=t.slice(0,12),n=t.slice(12),a=await crypto.subtle.importKey("raw",r,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),o=await crypto.subtle.decrypt({name:"AES-GCM",iv:e,tagLength:128},a,n);return new Uint8Array(o)}function j(){async function t(r,e){if(e.byteLength!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let n=await crypto.subtle.importKey("raw",e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),a=crypto.getRandomValues(new Uint8Array(12)),o=await crypto.subtle.encrypt({name:"AES-GCM",iv:a,tagLength:128},n,r),s=new Uint8Array(a.length+o.byteLength);return s.set(a,0),s.set(new Uint8Array(o),a.length),s}self.onmessage=async r=>{let e=r.data;try{let n=await t(e.data,e.rawSecret);self.postMessage({result:n})}catch(n){self.postMessage({error:n.message})}}}function P(){async function t(r,e){if(e.byteLength!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let n=r.slice(0,12),a=r.slice(12,r.byteLength),o=await crypto.subtle.importKey("raw",e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),s=await crypto.subtle.decrypt({name:"AES-GCM",iv:n,tagLength:128},o,a);return new Uint8Array(s)}self.onmessage=async r=>{let e=r.data;try{let n=await t(e.data,e.rawSecret);self.postMessage({result:n})}catch(n){self.postMessage({error:n.message})}}}function v(){return new Worker(URL.createObjectURL(new Blob(["("+j.toString()+")()"],{type:"text/javascript"})))}function J(){return new Worker(URL.createObjectURL(new Blob(["("+P.toString()+")()"],{type:"text/javascript"})))}var l=class{constructor(){this.worker=v()}async encrypt(r){let e=this,n=new Uint8Array(r.rawSecret.byteLength);n.set(r.rawSecret);let a=[],o=r.data instanceof Blob||r.data instanceof File?await r.data.arrayBuffer():r.data.buffer;return a.push(n.buffer),a.push(o),new Promise(async(s,i)=>{e.worker.onmessage=c=>{if(c.data.error){i(new Error(c.data.error));return}s(c.data.result)},e.worker.onerror=c=>{i(c)},e.worker.postMessage({data:o,rawSecret:n},a)})}},y=class{constructor(){this.worker=J()}async decrypt(r){let e=this,n=new Uint8Array(r.rawSecret.byteLength);n.set(r.rawSecret);let a=[],o=r.data instanceof Blob||r.data instanceof File?await r.data.arrayBuffer():r.data.buffer;return a.push(n.buffer),a.push(o),new Promise(async(s,i)=>{e.worker.onmessage=c=>{if(c.data.error){i(new Error(c.data.error));return}s(c.data.result)},e.worker.onerror=c=>{i(c)},e.worker.postMessage({data:o,rawSecret:n},a)})}};function u(t){return new TextEncoder().encode(t)}function M(t){return new TextDecoder().decode(t)}function N(t,r){for(let e=0;e<t.length;e++)t[e]=r[t[e]];return t}function O(t,r){let e=new Array(256);for(let n=0;n<256;n++){let a=r[n];e[a]=n}for(let n=0;n<t.length;n++)t[n]=e[t[n]];return t}function I(t){for(let r=t.length-1;r>0;r--){let e=Math.floor(Math.random()*(r+1));[t[r],t[e]]=[t[e],t[r]]}return t}function V(){let t=new Array(256);for(let e=0;e<256;e++)t[e]=e;I(t);let r=new Uint8Array(256);for(let e=0;e<256;e++)r[e]=t[e];return r}function _(t){let r=u(t),e=V();N(r,e);let n=new Uint8Array(r.length+e.length);return n.set(e,0),n.set(r,e.length),n}function H(t){let r=t.subarray(0,256),e=t.subarray(256);return O(e,r),M(e)}async function k(t){let r=await new Promise(e=>{let n=new FileReader;n.onload=()=>e(n.result),n.readAsDataURL(new Blob([t]))});return r.slice(r.indexOf(",")+1)}async function $(t){let r=await k(t);return C(r)}function C(t){return t.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function A(t){let r=t.replace(/-/g,"+").replace(/_/g,"/"),e=(4-r.length%4)%4;return r+"=".repeat(e)}function w(t){let r=A(t);return E(r)}function E(t){let r=atob(t),e=new Uint8Array(r.length);for(let n=0;n<r.length;n++)e[n]=r.charCodeAt(n);return e}async function q(t=!0){return await crypto.subtle.generateKey({name:"AES-GCM",length:256},t,["encrypt","decrypt"])}function Q(){return crypto.getRandomValues(new Uint8Array(16))}async function X(t,r=!0){let e=new TextEncoder().encode(t);return await crypto.subtle.importKey("raw",e,{name:"PBKDF2"},r,["deriveKey"])}function K(t,r=!0){return crypto.subtle.importKey("raw",t,{name:"AES-GCM",length:256},r,["encrypt","decrypt"])}async function Y(t,r,e=6e5){return await crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:e,hash:"SHA-256"},t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}function Z(t,r=!0){if(typeof t>"u"||t===null)return q(r);if(t instanceof Uint8Array)return K(t,r);if(typeof t=="string"){let e=w(t);if(e.length!==32)throw new Error("Secret must be 32 bytes (256 bits) long for AES-GCM.");return K(e,r)}throw new Error("Secret must be a string or Uint8Array.")}function W(){return crypto.getRandomValues(new Uint8Array(32))}async function ee(t){let r=await crypto.subtle.exportKey("raw",t);return new Uint8Array(r)}async function te(t){let r=await x(t);return ne(r)}function re(t){return{alg:"A256GCM",ext:!0,k:t,key_ops:["encrypt","decrypt"],kty:"oct"}}function ne(t){return t.k}async function x(t){return await crypto.subtle.exportKey("jwk",t)}function h(t){let r=new Uint8Array(8);for(let e=0;e<8;e++)r[e]=t%256,t=Math.floor(t/256);return r}function f(t){if(t.length!==8)throw new Error("Array length must be 8 bytes.");let r=0;for(let e=0;e<8;e++)r+=t[e]*Math.pow(256,e);return r}function p(t){let r=JSON.stringify(t),e=u(r),n=e.length,a=new Uint8Array(8+n);return a.set(h(n+8),0),a.set(e,8),a}function ae(t){return f(t.slice(0,8))}function d(t){let r=ae(t),e=new TextDecoder("utf-8").decode(t.slice(8,r));return JSON.parse(e)}function F(t,r,e=1024*512){let n=r*e,a=n+e;return a>t.size&&(a=t.size),n>=t.size?null:t.slice(n,a)}function U(t,r){return Math.ceil(t.size/r)}function m(t,r=512){return{fileName:t.name,fileSize:t.size,fileType:t.type,chunkSizeBytes:1024*r,totalChunks:Math.ceil(t.size/(1024*r)),finalChunkSize:t.size%(1024*r)}}async function D(t,r,e){let n=!e;e=e||new l;let a=await se(t,r,e),o=a.length,s=await ie(t,r,e),i=new Uint8Array(o+s.length+8);return i.set(h(o),0),i.set(a,8),i.set(s,8+o),s=null,a=null,n&&e.worker.terminate(),i}async function T(t,r,e){let n=!e;if(e=e||new y,t.size==0)throw new Error("File is empty.");if(t.size<8)throw new Error("File is too small to contain metadata.");let a=new Uint8Array(await t.slice(0,8).arrayBuffer()),o=f(a),s=t.slice(8+o,t.size),i=await e.decrypt({data:s,rawSecret:r});return n&&e.worker.terminate(),i}async function L(t,r,e){let n=!e;e=e||new l;let a=await t.arrayBuffer(),o=new Uint8Array(a),s=await e.encrypt({data:o,rawSecret:r});return n&&e.worker.terminate(),s}async function oe(t,r,e){let n=!e;e=e||new y;let a=await e.decrypt({data:t,rawSecret:r});return n&&e.worker.terminate(),a}async function R(t,r,e,n){let a=!n;e=e||512,n=n||new l;let o=m(t,e),s=p(o),i=await n.encrypt({data:s,rawSecret:r});return a&&n.worker.terminate(),s=null,o=null,i}async function se(t,r,e){e=e||new l;let n={fileName:t.name,fileSize:t.size,fileType:t.type},a=p(n);return await e.encrypt({data:a,rawSecret:r})}async function ie(t,r,e){return e=e||new l,await e.encrypt({data:t,rawSecret:r})}async function g(t,r,e){let n=!e;e=e||new y;let a=await t.slice(0,8).arrayBuffer(),o=new Uint8Array(a),s=f(o),i=t.slice(8,8+s),c=await e.decrypt({data:i,rawSecret:r});return n&&e.worker.terminate(),d(c)}var b=class{constructor(r,e,n){this.file=r,this.rawKey=e,this.chunkSizeKb=n||512,this.totalChunks=U(r,this.chunkSizeKb*1024),this.workerEncrypt=new l}getChunk(r){return F(this.file,r,this.chunkSizeKb*1024)}getMetaData(){return m(this.file,this.chunkSizeKb)}async encryptMetaData(){return await R(this.file,this.rawKey,this.chunkSizeKb,this.workerEncrypt)}async encryptChunk(r){let e=this.getChunk(r);if(!e)throw new Error("Chunk not found");return await L(e,this.rawKey,this.workerEncrypt)}terminate(){this.workerEncrypt.worker.terminate(),this.workerEncrypt=null,this.file=null,this.rawKey=null}};var S=class{constructor(r,e){this.file=r,this.rawKey=e,this.workerEncrypt=new l}async encrypt(){return await D(this.file,this.rawKey,this.workerEncrypt)}getMetaData(){return{fileName:this.file.name,fileSize:this.file.size,fileType:this.file.type}}terminate(){this.workerEncrypt.worker.terminate(),this.workerEncrypt=null,this.file=null,this.rawKey=null}},B=class{constructor(r,e){this.file=r,this.rawKey=e,this.workerDecrypt=new y}async decryptContent(){return await T(this.file,this.rawKey,this.workerDecrypt)}async decryptMetaData(){return await g(this.file,this.rawKey,this.workerDecrypt)}terminate(){this.workerDecrypt.worker.terminate(),this.workerDecrypt=null,this.file=null,this.rawKey=null}};export{b as MultipartFileEncryptor,B as SingleFileDecryptor,S as SingleFileEncryptor,y as WorkerDecrypt,l as WorkerEncrypt,C as base64ToBase64URL,E as base64ToBuffer,A as base64URLToBase64,w as base64URLToBuffer,p as bjson,d as bjsonParse,k as bufferToBase64,$ as bufferToBase64URL,M as bufferToString,Z as createCryptoKey,re as createJwkFromSecret,X as createMasterKeyFromPassword,H as decodeText,G as decryptBytes,oe as decryptFileChunk,g as decryptFileMetaData,Y as derivedKeyFromMasterKey,_ as encodeText,z as encryptBytes,x as exportJwk,ee as exportRawSecret,te as exportSecret,W as generateRawSecret,Q as generateSalt,u as stringToBuffer};
