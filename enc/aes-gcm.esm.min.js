async function j(t,r){if(r.length!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let e=await crypto.subtle.importKey("raw",r,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),n=crypto.getRandomValues(new Uint8Array(12)),a=await crypto.subtle.encrypt({name:"AES-GCM",iv:n,tagLength:128},e,t),i=new Uint8Array(a),o=new Uint8Array(n.length+i.length);return o.set(n,0),o.set(i,n.length),o}async function z(t,r){if(r.length!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let e=t.slice(0,12),n=t.slice(12),a=await crypto.subtle.importKey("raw",r,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:e,tagLength:128},a,n);return new Uint8Array(i)}function G(){async function t(r,e){if(e.length!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let n=await crypto.subtle.importKey("raw",e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),a=crypto.getRandomValues(new Uint8Array(12)),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:a,tagLength:128},n,r),o=new Uint8Array(i),s=new Uint8Array(a.length+o.length);return s.set(a,0),s.set(o,a.length),s}self.onmessage=async r=>{let e=r.data,n=e.data instanceof Blob?new Uint8Array(await e.data.arrayBuffer()):e.data,a=await t(n,e.rawSecret);self.postMessage({result:a})}}function v(){async function t(r,e){if(e.length!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let n=r.slice(0,12),a=r.slice(12,r.length),i=await crypto.subtle.importKey("raw",e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),o=await crypto.subtle.decrypt({name:"AES-GCM",iv:n,tagLength:128},i,a.buffer);return new Uint8Array(o)}self.onmessage=async r=>{let e=r.data,n=e.data instanceof Blob?new Uint8Array(await e.data.arrayBuffer()):e.data,a=await t(n,e.rawSecret);self.postMessage({result:a})}}function P(){return new Worker(URL.createObjectURL(new Blob(["("+G.toString()+")()"],{type:"text/javascript"})))}function J(){return new Worker(URL.createObjectURL(new Blob(["("+v.toString()+")()"],{type:"text/javascript"})))}var c=class{constructor(){this.worker=P()}encrypt(r){return new Promise((e,n)=>{this.worker.onmessage=a=>{e(a.data.result)},this.worker.onerror=a=>{n(a)},this.worker.postMessage(r)})}},l=class{constructor(){this.worker=J()}decrypt(r){return new Promise((e,n)=>{this.worker.onmessage=a=>{e(a.data.result)},this.worker.onerror=a=>{n(a)},this.worker.postMessage(r)})}};function y(t){return new TextEncoder().encode(t)}function k(t){return new TextDecoder().decode(t)}function N(t,r){for(let e=0;e<t.length;e++)t[e]=r[t[e]];return t}function O(t,r){let e=new Array(256);for(let n=0;n<256;n++){let a=r[n];e[a]=n}for(let n=0;n<t.length;n++)t[n]=e[t[n]];return t}function I(t){for(let r=t.length-1;r>0;r--){let e=Math.floor(Math.random()*(r+1));[t[r],t[e]]=[t[e],t[r]]}return t}function V(){let t=new Array(256);for(let e=0;e<256;e++)t[e]=e;I(t);let r=new Uint8Array(256);for(let e=0;e<256;e++)r[e]=t[e];return r}function _(t){let r=y(t),e=V();N(r,e);let n=new Uint8Array(r.length+e.length);return n.set(e,0),n.set(r,e.length),n}function H(t){let r=t.subarray(0,256),e=t.subarray(256);return O(e,r),k(e)}async function M(t){let r=await new Promise(e=>{let n=new FileReader;n.onload=()=>e(n.result),n.readAsDataURL(new Blob([t]))});return r.slice(r.indexOf(",")+1)}async function $(t){let r=await M(t);return S(r)}function S(t){return t.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function C(t){let r=t.replace(/-/g,"+").replace(/_/g,"/"),e=(4-r.length%4)%4;return r+"=".repeat(e)}function f(t){let r=C(t);return A(r)}function A(t){let r=atob(t),e=new Uint8Array(r.length);for(let n=0;n<r.length;n++)e[n]=r.charCodeAt(n);return e}async function q(t=!0){return await crypto.subtle.generateKey({name:"AES-GCM",length:256},t,["encrypt","decrypt"])}function Q(){return crypto.getRandomValues(new Uint8Array(16))}async function X(t,r=!0){let e=new TextEncoder().encode(t);return await crypto.subtle.importKey("raw",e,{name:"PBKDF2"},r,["deriveKey"])}function K(t,r=!0){return crypto.subtle.importKey("raw",t,{name:"AES-GCM",length:256},r,["encrypt","decrypt"])}async function Y(t,r,e=6e5){return await crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:e,hash:"SHA-256"},t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}function Z(t,r=!0){if(typeof t>"u"||t===null)return q(r);if(t instanceof Uint8Array)return K(t,r);if(typeof t=="string"){let e=f(t);if(e.length!==32)throw new Error("Secret must be 32 bytes (256 bits) long for AES-GCM.");return K(e,r)}throw new Error("Secret must be a string or Uint8Array.")}function W(){return crypto.getRandomValues(new Uint8Array(32))}async function ee(t){let r=await crypto.subtle.exportKey("raw",t);return new Uint8Array(r)}async function te(t){let r=await E(t);return ne(r)}function re(t){return{alg:"A256GCM",ext:!0,k:t,key_ops:["encrypt","decrypt"],kty:"oct"}}function ne(t){return t.k}async function E(t){return await crypto.subtle.exportKey("jwk",t)}function w(t){let r=new Uint8Array(8);for(let e=0;e<8;e++)r[e]=t%256,t=Math.floor(t/256);return r}function u(t){if(t.length!==8)throw new Error("Array length must be 8 bytes.");let r=0;for(let e=0;e<8;e++)r+=t[e]*Math.pow(256,e);return r}function p(t){let r=JSON.stringify(t),e=y(r),n=e.length,a=new Uint8Array(8+n);return a.set(w(n+8),0),a.set(e,8),a}function ae(t){return u(t.slice(0,8))}function h(t){let r=ae(t),e=new TextDecoder("utf-8").decode(t.slice(8,r));return JSON.parse(e)}function x(t,r,e=1024*512){let n=r*e,a=n+e;return a>t.size&&(a=t.size),n>=t.size?null:t.slice(n,a)}function F(t,r){return Math.ceil(t.size/r)}function d(t,r=512){return{fileName:t.name,fileSize:t.size,fileType:t.type,chunkSizeBytes:1024*r,totalChunks:Math.ceil(t.size/(1024*r)),finalChunkSize:t.size%(1024*r)}}async function U(t,r,e){let n=!e;e=e||new c;let a=await oe(t,r,e),i=a.length,o=await se(t,r,e),s=new Uint8Array(i+o.length+8);return s.set(w(i),0),s.set(a,8),s.set(o,8+i),o=null,a=null,n&&e.worker.terminate(),s}async function D(t,r,e){let n=!e;if(e=e||new l,t.size==0)throw new Error("File is empty.");if(t.size<8)throw new Error("File is too small to contain metadata.");let a=new Uint8Array(await t.slice(0,8).arrayBuffer()),i=u(a),o=t.slice(8+i,t.size),s=await e.decrypt({data:o,rawSecret:r});return n&&e.worker.terminate(),s}async function T(t,r,e){let n=!e;e=e||new c;let a=await t.arrayBuffer(),i=new Uint8Array(a),o=await e.encrypt({data:i,rawSecret:r});return n&&e.worker.terminate(),o}async function ie(t,r,e){let n=!e;e=e||new l;let a=await e.decrypt({data:t,rawSecret:r});return n&&e.worker.terminate(),a}async function L(t,r,e,n){let a=!n;e=e||512,n=n||new c;let i=d(t,e),o=p(i),s=await n.encrypt({data:o,rawSecret:r});return a&&n.worker.terminate(),o=null,i=null,s}async function oe(t,r,e){e=e||new c;let n={fileName:t.name,fileSize:t.size,fileType:t.type},a=p(n);return await e.encrypt({data:a,rawSecret:r})}async function se(t,r,e){return e=e||new c,await e.encrypt({data:t,rawSecret:r})}async function m(t,r,e){let n=!e;e=e||new l;let a=await t.slice(0,8).arrayBuffer(),i=new Uint8Array(a),o=u(i),s=t.slice(8,8+o),R=await e.decrypt({data:s,rawSecret:r});return n&&e.worker.terminate(),h(R)}var g=class{constructor(r,e,n){this.file=r,this.rawKey=e,this.chunkSizeKb=n||512,this.totalChunks=F(r,this.chunkSizeKb*1024),this.workerEncrypt=new c}getChunk(r){return x(this.file,r,this.chunkSizeKb*1024)}getMetaData(){return d(this.file,this.chunkSizeKb)}async encryptMetaData(){return await L(this.file,this.rawKey,this.chunkSizeKb,this.workerEncrypt)}async encryptChunk(r){let e=this.getChunk(r);if(!e)throw new Error("Chunk not found");return await T(e,this.rawKey,this.workerEncrypt)}terminate(){this.workerEncrypt.worker.terminate(),this.workerEncrypt=null,this.file=null,this.rawKey=null}};var b=class{constructor(r,e){this.file=r,this.rawKey=e,this.workerEncrypt=new c}async encrypt(){return await U(this.file,this.rawKey,this.workerEncrypt)}getMetaData(){return{fileName:this.file.name,fileSize:this.file.size,fileType:this.file.type}}terminate(){this.workerEncrypt.worker.terminate(),this.workerEncrypt=null,this.file=null,this.rawKey=null}},B=class{constructor(r,e){this.file=r,this.rawKey=e,this.workerDecrypt=new l}async decryptContent(){return await D(this.file,this.rawKey,this.workerDecrypt)}async decryptMetaData(){return await m(this.file,this.rawKey,this.workerDecrypt)}terminate(){this.workerDecrypt.worker.terminate(),this.workerDecrypt=null,this.file=null,this.rawKey=null}};export{g as MultipartFileEncryptor,B as SingleFileDecryptor,b as SingleFileEncryptor,l as WorkerDecrypt,c as WorkerEncrypt,S as base64ToBase64URL,A as base64ToBuffer,C as base64URLToBase64,f as base64URLToBuffer,p as bjson,h as bjsonParse,M as bufferToBase64,$ as bufferToBase64URL,k as bufferToString,Z as createCryptoKey,re as createJwkFromSecret,X as createMasterKeyFromPassword,H as decodeText,z as decryptBytes,ie as decryptFileChunk,m as decryptFileMetaData,Y as derivedKeyFromMasterKey,_ as encodeText,j as encryptBytes,E as exportJwk,ee as exportRawSecret,te as exportSecret,W as generateRawSecret,Q as generateSalt,y as stringToBuffer};
