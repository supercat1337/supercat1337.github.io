async function G(t,r){if(r.length!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let e=await crypto.subtle.importKey("raw",r,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),n=crypto.getRandomValues(new Uint8Array(12)),a=await crypto.subtle.encrypt({name:"AES-GCM",iv:n,tagLength:128},e,t),o=new Uint8Array(a),s=new Uint8Array(n.length+o.length);return s.set(n,0),s.set(o,n.length),s}async function j(t,r){if(r.length!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let e=t.slice(0,12),n=t.slice(12),a=await crypto.subtle.importKey("raw",r,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),o=await crypto.subtle.decrypt({name:"AES-GCM",iv:e,tagLength:128},a,n);return new Uint8Array(o)}function P(){async function t(r,e){if(e.byteLength!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let n=await crypto.subtle.importKey("raw",e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),a=crypto.getRandomValues(new Uint8Array(12)),o=await crypto.subtle.encrypt({name:"AES-GCM",iv:a,tagLength:128},n,r),s=new Uint8Array(a.length+o.byteLength);return s.set(a,0),s.set(new Uint8Array(o),a.length),s}self.onmessage=async r=>{let e=r.data;try{let n=await t(e.data,e.rawSecret);self.postMessage({result:n})}catch(n){self.postMessage({error:n.message})}}}function v(){async function t(r,e){if(e.byteLength!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let n=r.slice(0,12),a=r.slice(12,r.byteLength),o=await crypto.subtle.importKey("raw",e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),s=await crypto.subtle.decrypt({name:"AES-GCM",iv:n,tagLength:128},o,a);return new Uint8Array(s)}self.onmessage=async r=>{let e=r.data;try{let n=await t(e.data,e.rawSecret);self.postMessage({result:n})}catch(n){self.postMessage({error:n.message})}}}function J(){return new Worker(URL.createObjectURL(new Blob(["("+P.toString()+")()"],{type:"text/javascript"})))}function N(){return new Worker(URL.createObjectURL(new Blob(["("+v.toString()+")()"],{type:"text/javascript"})))}var l=class{constructor(){this.worker=J()}async encrypt(r){let e=this,n=new Uint8Array(r.rawSecret.byteLength);n.set(r.rawSecret);let a=[],o=r.data instanceof Blob||r.data instanceof File?await r.data.arrayBuffer():r.data.buffer;return a.push(n.buffer),a.push(o),new Promise(async(s,i)=>{e.worker.onmessage=c=>{if(c.data.error){i(new Error(c.data.error));return}s(c.data.result)},e.worker.onerror=c=>{i(c)},e.worker.postMessage({data:o,rawSecret:n},a)})}},y=class{constructor(){this.worker=N()}async decrypt(r){let e=this,n=new Uint8Array(r.rawSecret.byteLength);n.set(r.rawSecret);let a=[],o=r.data instanceof Blob||r.data instanceof File?await r.data.arrayBuffer():r.data.buffer;return a.push(n.buffer),a.push(o),new Promise(async(s,i)=>{e.worker.onmessage=c=>{if(c.data.error){i(new Error(c.data.error));return}s(c.data.result)},e.worker.onerror=c=>{i(c)},e.worker.postMessage({data:o,rawSecret:n},a)})}};function u(t){return new TextEncoder().encode(t)}function k(t){return new TextDecoder().decode(t)}function O(t,r){for(let e=0;e<t.length;e++)t[e]=r[t[e]];return t}function I(t,r){let e=new Array(256);for(let n=0;n<256;n++){let a=r[n];e[a]=n}for(let n=0;n<t.length;n++)t[n]=e[t[n]];return t}function V(t){for(let r=t.length-1;r>0;r--){let e=Math.floor(Math.random()*(r+1));[t[r],t[e]]=[t[e],t[r]]}return t}function _(){let t=new Array(256);for(let e=0;e<256;e++)t[e]=e;V(t);let r=new Uint8Array(256);for(let e=0;e<256;e++)r[e]=t[e];return r}function H(t){let r=u(t),e=_();O(r,e);let n=new Uint8Array(r.length+e.length);return n.set(e,0),n.set(r,e.length),n}function $(t){let r=t.subarray(0,256),e=t.subarray(256);return I(e,r),k(e)}async function M(t){let r=await new Promise(e=>{let n=new FileReader;n.onload=()=>e(n.result),n.readAsDataURL(new Blob([t]))});return r.slice(r.indexOf(",")+1)}async function q(t){let r=await M(t);return C(r)}function C(t){return t.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function E(t){let r=t.replace(/-/g,"+").replace(/_/g,"/"),e=(4-r.length%4)%4;return r+"=".repeat(e)}function p(t){let r=E(t);return A(r)}function A(t){let r=atob(t),e=new Uint8Array(r.length);for(let n=0;n<r.length;n++)e[n]=r.charCodeAt(n);return e}async function Q(t=!0){return await crypto.subtle.generateKey({name:"AES-GCM",length:256},t,["encrypt","decrypt"])}function X(){return crypto.getRandomValues(new Uint8Array(16))}async function Y(t,r=!0){let e=new TextEncoder().encode(t);return await crypto.subtle.importKey("raw",e,{name:"PBKDF2"},r,["deriveKey"])}function F(t,r=!0){return crypto.subtle.importKey("raw",t,{name:"AES-GCM",length:256},r,["encrypt","decrypt"])}async function Z(t,r,e=6e5){return await crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:e,hash:"SHA-256"},t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}function W(t,r=!0){if(typeof t>"u"||t===null)return Q(r);if(t instanceof Uint8Array)return F(t,r);if(typeof t=="string"){let e=p(t);if(e.length!==32)throw new Error("Secret must be 32 bytes (256 bits) long for AES-GCM.");return F(e,r)}throw new Error("Secret must be a string or Uint8Array.")}function ee(){return crypto.getRandomValues(new Uint8Array(32))}async function te(t){let r=await crypto.subtle.exportKey("raw",t);return new Uint8Array(r)}async function re(t){let r=await K(t);return ae(r)}function ne(t){return{alg:"A256GCM",ext:!0,k:t,key_ops:["encrypt","decrypt"],kty:"oct"}}function ae(t){return t.k}async function K(t){return await crypto.subtle.exportKey("jwk",t)}function h(t){let r=new Uint8Array(8);for(let e=0;e<8;e++)r[e]=t%256,t=Math.floor(t/256);return r}function f(t){if(t.length!==8)throw new Error("Array length must be 8 bytes.");let r=0;for(let e=0;e<8;e++)r+=t[e]*Math.pow(256,e);return r}function w(t){let r=JSON.stringify(t),e=u(r),n=e.length,a=new Uint8Array(8+n);return a.set(h(n+8),0),a.set(e,8),a}function oe(t){return f(t.slice(0,8))}function d(t){let r=oe(t),e=new TextDecoder("utf-8").decode(t.slice(8,r));return JSON.parse(e)}function x(t,r,e=1024*512){let n=r*e,a=n+e;return a>t.size&&(a=t.size),n>=t.size?null:t.slice(n,a)}function D(t,r){return Math.ceil(t.size/r)}function m(t,r=512){return{fileName:t.name,fileSize:t.size,fileType:t.type,chunkSizeBytes:1024*r,totalChunks:Math.ceil(t.size/(1024*r)),finalChunkSize:t.size%(1024*r)}}async function U(t,r,e){if(t.size==0)throw new Error("File is empty.");let n=!e;e=e||new l;let a=await ie(t,r,e),o=a.length,s=await ce(t,r,e),i=new Uint8Array(o+s.length+8);return i.set(h(o),0),i.set(a,8),i.set(s,8+o),s=null,a=null,n&&e.worker.terminate(),i}async function T(t,r,e){let n=!e;if(e=e||new y,t.size==0)throw new Error("File is empty.");if(t.size<8)throw new Error("File is too small to contain metadata.");let a=new Uint8Array(await t.slice(0,8).arrayBuffer()),o=f(a),s=t.slice(8+o,t.size),i=await e.decrypt({data:s,rawSecret:r});return n&&e.worker.terminate(),i}async function L(t,r,e){if(t.size==0)throw new Error("Chunk is empty.");let n=!e;e=e||new l;let a=await t.arrayBuffer(),o=new Uint8Array(a),s=await e.encrypt({data:o,rawSecret:r});return n&&e.worker.terminate(),s}async function se(t,r,e){if(t.size==0)throw new Error("File is empty.");let n=!e;e=e||new y;let a=await e.decrypt({data:t,rawSecret:r});return n&&e.worker.terminate(),a}async function R(t,r,e,n){if(t.size==0)throw new Error("File is empty.");let a=!n;e=e||512,n=n||new l;let o=m(t,e),s=w(o),i;try{i=await n.encrypt({data:s,rawSecret:r})}catch(c){throw a&&n.worker.terminate(),new Error(c)}return a&&n.worker.terminate(),s=null,o=null,i}async function ie(t,r,e){e=e||new l;let n={fileName:t.name,fileSize:t.size,fileType:t.type},a=w(n);return await e.encrypt({data:a,rawSecret:r})}async function ce(t,r,e){return e=e||new l,await e.encrypt({data:t,rawSecret:r})}async function g(t,r,e){let n=!e;e=e||new y;let a=await t.slice(0,8).arrayBuffer(),o=new Uint8Array(a),s=f(o),i=t.slice(8,8+s),c;try{c=await e.decrypt({data:i,rawSecret:r})}catch(z){throw n&&e.worker.terminate(),console.error("Error decrypting metadata:",z),new Error("Failed to decrypt metadata. Please check the key and file.")}return n&&e.worker.terminate(),console.log("Decrypted metadata:",c),d(c)}var b=class{constructor(r,e,n){this.file=r,this.rawKey=e,this.chunkSizeKb=n||512,this.totalChunks=D(r,this.chunkSizeKb*1024),this.workerEncrypt=new l}getChunk(r){return x(this.file,r,this.chunkSizeKb*1024)}getMetaData(){return m(this.file,this.chunkSizeKb)}async encryptMetaData(){return await R(this.file,this.rawKey,this.chunkSizeKb,this.workerEncrypt)}async encryptChunk(r){let e=this.getChunk(r);if(!e)throw new Error("Chunk not found");return await L(e,this.rawKey,this.workerEncrypt)}terminate(){this.workerEncrypt.worker.terminate(),this.workerEncrypt=null,this.file=null,this.rawKey=null}};var S=class{constructor(r,e){this.file=r,this.rawKey=e,this.workerEncrypt=new l}async encrypt(){return await U(this.file,this.rawKey,this.workerEncrypt)}getMetaData(){return{fileName:this.file.name,fileSize:this.file.size,fileType:this.file.type}}terminate(){this.workerEncrypt.worker.terminate(),this.workerEncrypt=null,this.file=null,this.rawKey=null}},B=class{constructor(r,e){this.file=r,this.rawKey=e,this.workerDecrypt=new y}async decryptContent(){return await T(this.file,this.rawKey,this.workerDecrypt)}async decryptMetaData(){return await g(this.file,this.rawKey,this.workerDecrypt)}terminate(){this.workerDecrypt.worker.terminate(),this.workerDecrypt=null,this.file=null,this.rawKey=null}};export{b as MultipartFileEncryptor,B as SingleFileDecryptor,S as SingleFileEncryptor,y as WorkerDecrypt,l as WorkerEncrypt,C as base64ToBase64URL,A as base64ToBuffer,E as base64URLToBase64,p as base64URLToBuffer,w as bjson,d as bjsonParse,M as bufferToBase64,q as bufferToBase64URL,k as bufferToString,W as createCryptoKey,ne as createJwkFromSecret,Y as createMasterKeyFromPassword,$ as decodeText,j as decryptBytes,se as decryptFileChunk,g as decryptFileMetaData,Z as derivedKeyFromMasterKey,H as encodeText,G as encryptBytes,K as exportJwk,te as exportRawSecret,re as exportSecret,ee as generateRawSecret,X as generateSalt,u as stringToBuffer};
