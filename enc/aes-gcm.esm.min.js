async function j(e,r){if(r.length!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let t=await crypto.subtle.importKey("raw",r,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),n=crypto.getRandomValues(new Uint8Array(12)),a=await crypto.subtle.encrypt({name:"AES-GCM",iv:n,tagLength:128},t,e),o=new Uint8Array(a),i=new Uint8Array(n.length+o.length);return i.set(n,0),i.set(o,n.length),i}async function z(e,r){if(r.length!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let t=e.slice(0,12),n=e.slice(12),a=await crypto.subtle.importKey("raw",r,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),o=await crypto.subtle.decrypt({name:"AES-GCM",iv:t,tagLength:128},a,n);return new Uint8Array(o)}function G(){async function e(r,t){if(t.byteLength!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let n=await crypto.subtle.importKey("raw",t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),a=crypto.getRandomValues(new Uint8Array(12)),o=await crypto.subtle.encrypt({name:"AES-GCM",iv:a,tagLength:128},n,r),i=new Uint8Array(a.length+o.byteLength);return i.set(a,0),i.set(new Uint8Array(o),a.length),i}self.onmessage=async r=>{let t=r.data,n=await e(t.data,t.rawSecret);self.postMessage({result:n})}}function v(){async function e(r,t){if(t.byteLength!==32)throw new Error("Key must be 32 bytes (256 bits) long for AES-GCM.");let n=r.slice(0,12),a=r.slice(12,r.byteLength),o=await crypto.subtle.importKey("raw",t,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),i=await crypto.subtle.decrypt({name:"AES-GCM",iv:n,tagLength:128},o,a);return new Uint8Array(i)}self.onmessage=async r=>{let t=r.data,n=await e(t.data,t.rawSecret);self.postMessage({result:n})}}function P(){return new Worker(URL.createObjectURL(new Blob(["("+G.toString()+")()"],{type:"text/javascript"})))}function J(){return new Worker(URL.createObjectURL(new Blob(["("+v.toString()+")()"],{type:"text/javascript"})))}var c=class{constructor(){this.worker=P()}encrypt(r){return new Promise(async(t,n)=>{this.worker.onmessage=s=>{t(s.data.result)},this.worker.onerror=s=>{n(s)};let a=new Uint8Array(r.rawSecret.byteLength);a.set(r.rawSecret);let o=[],i=r.data instanceof Blob||r.data instanceof File?await r.data.arrayBuffer():r.data.buffer;o.push(a.buffer),o.push(i),this.worker.postMessage({data:i,rawSecret:a},o)})}},l=class{constructor(){this.worker=J()}decrypt(r){return new Promise(async(t,n)=>{this.worker.onmessage=s=>{t(s.data.result)},this.worker.onerror=s=>{n(s)};let a=new Uint8Array(r.rawSecret.byteLength);a.set(r.rawSecret);let o=[],i=r.data instanceof Blob||r.data instanceof File?await r.data.arrayBuffer():r.data.buffer;o.push(a.buffer),o.push(i),this.worker.postMessage({data:i,rawSecret:a},o)})}};function y(e){return new TextEncoder().encode(e)}function B(e){return new TextDecoder().decode(e)}function N(e,r){for(let t=0;t<e.length;t++)e[t]=r[e[t]];return e}function O(e,r){let t=new Array(256);for(let n=0;n<256;n++){let a=r[n];t[a]=n}for(let n=0;n<e.length;n++)e[n]=t[e[n]];return e}function I(e){for(let r=e.length-1;r>0;r--){let t=Math.floor(Math.random()*(r+1));[e[r],e[t]]=[e[t],e[r]]}return e}function V(){let e=new Array(256);for(let t=0;t<256;t++)e[t]=t;I(e);let r=new Uint8Array(256);for(let t=0;t<256;t++)r[t]=e[t];return r}function _(e){let r=y(e),t=V();N(r,t);let n=new Uint8Array(r.length+t.length);return n.set(t,0),n.set(r,t.length),n}function H(e){let r=e.subarray(0,256),t=e.subarray(256);return O(t,r),B(t)}async function k(e){let r=await new Promise(t=>{let n=new FileReader;n.onload=()=>t(n.result),n.readAsDataURL(new Blob([e]))});return r.slice(r.indexOf(",")+1)}async function $(e){let r=await k(e);return M(r)}function M(e){return e.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}function C(e){let r=e.replace(/-/g,"+").replace(/_/g,"/"),t=(4-r.length%4)%4;return r+"=".repeat(t)}function p(e){let r=C(e);return A(r)}function A(e){let r=atob(e),t=new Uint8Array(r.length);for(let n=0;n<r.length;n++)t[n]=r.charCodeAt(n);return t}async function q(e=!0){return await crypto.subtle.generateKey({name:"AES-GCM",length:256},e,["encrypt","decrypt"])}function Q(){return crypto.getRandomValues(new Uint8Array(16))}async function X(e,r=!0){let t=new TextEncoder().encode(e);return await crypto.subtle.importKey("raw",t,{name:"PBKDF2"},r,["deriveKey"])}function K(e,r=!0){return crypto.subtle.importKey("raw",e,{name:"AES-GCM",length:256},r,["encrypt","decrypt"])}async function Y(e,r,t=6e5){return await crypto.subtle.deriveKey({name:"PBKDF2",salt:r,iterations:t,hash:"SHA-256"},e,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}function Z(e,r=!0){if(typeof e>"u"||e===null)return q(r);if(e instanceof Uint8Array)return K(e,r);if(typeof e=="string"){let t=p(e);if(t.length!==32)throw new Error("Secret must be 32 bytes (256 bits) long for AES-GCM.");return K(t,r)}throw new Error("Secret must be a string or Uint8Array.")}function W(){return crypto.getRandomValues(new Uint8Array(32))}async function ee(e){let r=await crypto.subtle.exportKey("raw",e);return new Uint8Array(r)}async function te(e){let r=await E(e);return ne(r)}function re(e){return{alg:"A256GCM",ext:!0,k:e,key_ops:["encrypt","decrypt"],kty:"oct"}}function ne(e){return e.k}async function E(e){return await crypto.subtle.exportKey("jwk",e)}function w(e){let r=new Uint8Array(8);for(let t=0;t<8;t++)r[t]=e%256,e=Math.floor(e/256);return r}function u(e){if(e.length!==8)throw new Error("Array length must be 8 bytes.");let r=0;for(let t=0;t<8;t++)r+=e[t]*Math.pow(256,t);return r}function f(e){let r=JSON.stringify(e),t=y(r),n=t.length,a=new Uint8Array(8+n);return a.set(w(n+8),0),a.set(t,8),a}function ae(e){return u(e.slice(0,8))}function h(e){let r=ae(e),t=new TextDecoder("utf-8").decode(e.slice(8,r));return JSON.parse(t)}function x(e,r,t=1024*512){let n=r*t,a=n+t;return a>e.size&&(a=e.size),n>=e.size?null:e.slice(n,a)}function F(e,r){return Math.ceil(e.size/r)}function d(e,r=512){return{fileName:e.name,fileSize:e.size,fileType:e.type,chunkSizeBytes:1024*r,totalChunks:Math.ceil(e.size/(1024*r)),finalChunkSize:e.size%(1024*r)}}async function U(e,r,t){let n=!t;t=t||new c;let a=await ie(e,r,t),o=a.length,i=await se(e,r,t),s=new Uint8Array(o+i.length+8);return s.set(w(o),0),s.set(a,8),s.set(i,8+o),i=null,a=null,n&&t.worker.terminate(),s}async function D(e,r,t){let n=!t;if(t=t||new l,e.size==0)throw new Error("File is empty.");if(e.size<8)throw new Error("File is too small to contain metadata.");let a=new Uint8Array(await e.slice(0,8).arrayBuffer()),o=u(a),i=e.slice(8+o,e.size),s=await t.decrypt({data:i,rawSecret:r});return n&&t.worker.terminate(),s}async function T(e,r,t){let n=!t;t=t||new c;let a=await e.arrayBuffer(),o=new Uint8Array(a),i=await t.encrypt({data:o,rawSecret:r});return n&&t.worker.terminate(),i}async function oe(e,r,t){let n=!t;t=t||new l;let a=await t.decrypt({data:e,rawSecret:r});return n&&t.worker.terminate(),a}async function L(e,r,t,n){let a=!n;t=t||512,n=n||new c;let o=d(e,t),i=f(o),s=await n.encrypt({data:i,rawSecret:r});return a&&n.worker.terminate(),i=null,o=null,s}async function ie(e,r,t){t=t||new c;let n={fileName:e.name,fileSize:e.size,fileType:e.type},a=f(n);return await t.encrypt({data:a,rawSecret:r})}async function se(e,r,t){return t=t||new c,await t.encrypt({data:e,rawSecret:r})}async function m(e,r,t){let n=!t;t=t||new l;let a=await e.slice(0,8).arrayBuffer(),o=new Uint8Array(a),i=u(o),s=e.slice(8,8+i),R=await t.decrypt({data:s,rawSecret:r});return n&&t.worker.terminate(),h(R)}var g=class{constructor(r,t,n){this.file=r,this.rawKey=t,this.chunkSizeKb=n||512,this.totalChunks=F(r,this.chunkSizeKb*1024),this.workerEncrypt=new c}getChunk(r){return x(this.file,r,this.chunkSizeKb*1024)}getMetaData(){return d(this.file,this.chunkSizeKb)}async encryptMetaData(){return await L(this.file,this.rawKey,this.chunkSizeKb,this.workerEncrypt)}async encryptChunk(r){let t=this.getChunk(r);if(!t)throw new Error("Chunk not found");return await T(t,this.rawKey,this.workerEncrypt)}terminate(){this.workerEncrypt.worker.terminate(),this.workerEncrypt=null,this.file=null,this.rawKey=null}};var b=class{constructor(r,t){this.file=r,this.rawKey=t,this.workerEncrypt=new c}async encrypt(){return await U(this.file,this.rawKey,this.workerEncrypt)}getMetaData(){return{fileName:this.file.name,fileSize:this.file.size,fileType:this.file.type}}terminate(){this.workerEncrypt.worker.terminate(),this.workerEncrypt=null,this.file=null,this.rawKey=null}},S=class{constructor(r,t){this.file=r,this.rawKey=t,this.workerDecrypt=new l}async decryptContent(){return await D(this.file,this.rawKey,this.workerDecrypt)}async decryptMetaData(){return await m(this.file,this.rawKey,this.workerDecrypt)}terminate(){this.workerDecrypt.worker.terminate(),this.workerDecrypt=null,this.file=null,this.rawKey=null}};export{g as MultipartFileEncryptor,S as SingleFileDecryptor,b as SingleFileEncryptor,l as WorkerDecrypt,c as WorkerEncrypt,M as base64ToBase64URL,A as base64ToBuffer,C as base64URLToBase64,p as base64URLToBuffer,f as bjson,h as bjsonParse,k as bufferToBase64,$ as bufferToBase64URL,B as bufferToString,Z as createCryptoKey,re as createJwkFromSecret,X as createMasterKeyFromPassword,H as decodeText,z as decryptBytes,oe as decryptFileChunk,m as decryptFileMetaData,Y as derivedKeyFromMasterKey,_ as encodeText,j as encryptBytes,E as exportJwk,ee as exportRawSecret,te as exportSecret,W as generateRawSecret,Q as generateSalt,y as stringToBuffer};
