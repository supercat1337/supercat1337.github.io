var S = class {
    #e = new Map();
    #t = !1;
    autoRegister = !1;
    #s = new Map();
    #d = -1;
    #a = new Map();
    #i = new Map();
    #n = !1;
    #o = 1;
    noLimitsToEmit = !1;
    name = "";
    setListenerRunnerStrategy(e) {
        this.#o = e;
    }
    getListenerRunnerStrategy() {
        return this.#o;
    }
    #h(e) {
        let t = ++this.#d;
        return this.#a.set(t, e), this.#i.set(t, 0), t;
    }
    #b(e) {
        this.#a.delete(e);
    }
    #r(e) {
        for (let [t, r] of this.#a) if (r === e) return t;
        return -1;
    }
    #u(e, t) {
        (this.#e.get(e) || new Set()).add(t);
        let s = this.#i.get(t) || 0;
        s++, this.#i.set(t, s);
    }
    #l(e, t) {
        (this.#e.get(e) || new Set()).delete(t);
        let s = this.#i.get(t) || 1;
        s--, this.#i.set(t, s), this.#p(t);
    }
    #p(e) {
        if ((this.#i.get(e) || 0) == 0) {
            this.#b(e), this.#i.delete(e);
            return;
        }
    }
    mute() {
        this.#t = !0;
    }
    unmute() {
        (this.#t = !1), this.#f();
    }
    isMuted() {
        return this.#t;
    }
    #f() {
        if (this.#s.size === 0) return;
        this.#n = !0;
        let e = new Map();
        this.#e.forEach((r, s) => {
            if (this.#s.has(s)) {
                let i = this.#s.get(s) || [];
                r.forEach((l) => {
                    e.set(l, i);
                });
            }
        }),
            this.#s.clear();
        let t = Array.from(e.keys());
        this.#o == 0 && t.sort((r, s) => r - s),
            t.forEach((r) => {
                let s = e.get(r) || [],
                    i = this.#a.get(r);
                try {
                    i && i(...s);
                } catch (l) {
                    console.error(l);
                }
            }),
            (this.#n = !1);
    }
    registerEvents(...e) {
        e.forEach((t) => {
            this.#e.has(t) || this.#e.set(t, new Set());
        });
    }
    unregisterEvents(...e) {
        e.forEach((t) => {
            if (!this.#e.has(t)) return;
            let r = this.#e.get(t);
            r &&
                (r.forEach((s) => {
                    this.#l(t, s);
                }),
                this.#e.delete(t));
        });
    }
    unregisterAllEvents() {
        this.#e.clear(), this.#a.clear(), this.#i.clear(), this.#s.clear();
    }
    on(e, t) {
        let r = () => {};
        if (this.autoRegister == !1) {
            if (!this.#e.has(e)) return r;
        } else this.registerEvents(e);
        let s = this.#h(t);
        this.#u(e, s);
        let i = this;
        return function () {
            i.#l(e, s);
        };
    }
    onAny(e, t) {
        this.autoRegister == !0 && this.registerEvents(...e);
        let r = Array.from(e).filter((i) => this.#e.has(i));
        if (r.length == 0) return () => {};
        let s = this.#h(t);
        return (
            r.forEach((i) => {
                this.#u(i, s);
            }),
            () => {
                r.forEach((i) => {
                    this.#l(i, s);
                });
            }
        );
    }
    removeListener(e, t) {
        if (!this.#e.has(e)) return;
        let r = this.#r(t);
        r != -1 && this.#l(e, r);
    }
    removeAllListeners(e) {
        if (!this.#e.has(e)) return;
        (this.#e.get(e) || new Set()).forEach((r) => {
            this.#l(e, r);
        });
    }
    off(e, t) {
        this.removeListener(e, t);
    }
    hasEvent(e) {
        return this.#e.has(e);
    }
    hasListeners(e) {
        return (this.#e.get(e) || new Set()).size > 0;
    }
    getNumberOfListeners(e) {
        return (this.#e.get(e) || new Set()).size;
    }
    emit(e, ...t) {
        if (!this.noLimitsToEmit && this.#n)
            throw new Error(
                `Cannot emit event ${e} while listeners are running`,
                {
                    cause: {
                        name: this.name,
                        events: Array.from(this.#e.keys()),
                    },
                }
            );
        this.#e.has(e) && (this.#t ? this.#s.set(e, t) : this.#v(e, ...t));
    }
    #v(e, ...t) {
        let r = this.#e.get(e) || new Set();
        (this.#n = !0),
            r.forEach((s) => {
                let i = this.#a.get(s);
                try {
                    i && i(...t);
                } catch (l) {
                    console.error(
                        `

EventEmitterExt (name = ${this.name}): Exception in listener for event ${e}`,
                        `
error:`,
                        l,
                        `
args: `,
                        t,
                        `
listener:`,
                        i?.toString(),
                        `

`
                    );
                }
            }),
            (this.#n = !1);
    }
    emitMany(e, ...t) {
        if (this.#n)
            throw new Error("Cannot call emitMany while listeners are running");
        e.forEach((r) => {
            this.#e.has(r) && this.#s.set(r, t);
        }),
            this.#t || this.#f();
    }
    once(e, t) {
        let r = this,
            s = this.on(e, () => {
                s(), t.apply(r, arguments);
            });
        return s;
    }
    waitForEvent(e, t = 0) {
        return new Promise((r) => {
            let s,
                i = this.on(e, () => {
                    t > 0 && clearTimeout(s), i(), r(!0);
                });
            t > 0 &&
                (s = setTimeout(() => {
                    i(), r(!1);
                }, t));
        });
    }
    waitForAnyEvent(e, t = 0) {
        return new Promise((r) => {
            let s,
                i = [],
                l = () => {
                    t > 0 && clearTimeout(s),
                        i.forEach((a) => {
                            a();
                        }),
                        r(!0);
                };
            e.forEach((a) => {
                i.push(this.on(a, l));
            }),
                t > 0 &&
                    (s = setTimeout(() => {
                        l(), r(!1);
                    }, t));
        });
    }
    getListeners(e) {
        if (!this.#e.has(e)) return [];
        let t = this.#e.get(e) || new Set(),
            r = [];
        return (
            t.forEach((s) => {
                let i = this.#a.get(s);
                i && r.push(i);
            }),
            r
        );
    }
    getEventNames() {
        return Array.from(this.#e.keys());
    }
};
var y = class {
    #e;
    #t;
    constructor(e, t, r) {
        (this.#t = e), (this.#e = t), (this.value = r);
    }
    set value(e) {
        this.#t.setItem(this.#e, e);
    }
    get value() {
        return this.#t.getItem(this.#e);
    }
    get name() {
        return this.#e;
    }
    subscribe(e, t) {
        return this.#t.subscribe(this.#e, e, t);
    }
    clearSubscribers() {
        return this.#t.clearItemSubscribers(this.#e);
    }
    hasSubscribers() {
        return this.#t.hasSubscribers(this.#e);
    }
    setCompareFunction(e) {
        return this.#t.setCompareFunction(this.#e, e);
    }
    get store() {
        return this.#t;
    }
    onHasSubscribers(e) {
        return this.#t.onHasSubscribers(this.#e, e);
    }
    onNoSubscribers(e) {
        return this.#t.onNoSubscribers(this.#e, e);
    }
};
function C(n) {
    return typeof n == "object" && n !== null && !Array.isArray(n);
}
function Y(n, e) {
    if (n.length !== e.length) return !1;
    for (let t = 0; t < n.length; t++) if (!A(n[t], e[t])) return !1;
    return !0;
}
function q(n, e) {
    if (n === e) return !0;
    if (!C(n) || !C(e)) return !1;
    let t = Object.keys(n),
        r = Object.keys(e);
    if (t.length !== r.length) return !1;
    for (let s = 0; s < t.length; s++) {
        let i = t[s];
        if (!Object.prototype.hasOwnProperty.call(e, i) || !A(n[i], e[i]))
            return !1;
    }
    return !0;
}
function A(n, e) {
    return n === e
        ? !0
        : typeof n != typeof e ||
          n === null ||
          e === null ||
          n === void 0 ||
          e === void 0
        ? !1
        : Array.isArray(n) || Array.isArray(e)
        ? Array.isArray(n) && Array.isArray(e)
            ? Y(n, e)
            : !1
        : q(n, e);
}
function j(n, e) {
    var t,
        r = (...s) => {
            var i = this,
                l = function () {
                    (t = null), n.apply(i, s);
                };
            clearTimeout(t), (t = setTimeout(l, e));
        };
    return r;
}
function G(n) {
    var e = new Set();
    for (let t = 0; t < n.length; t++) e.add(n[t]);
    return e;
}
var E = class {
        #e;
        #t;
        constructor(e, t, r) {
            (this.#t = e),
                (this.#e = t),
                typeof r < "u" && this.#t.createCollectionItem(this.#e, r);
        }
        set value(e) {
            this.#t.setItem(this.#e, e);
        }
        get value() {
            return this.#t.getItem(this.#e);
        }
        set content(e) {
            this.#t.setItem(this.#e, e);
        }
        get content() {
            return this.#t.getItem(this.#e);
        }
        get name() {
            return this.#e;
        }
        subscribe(e, t) {
            return this.#t.subscribe(this.#e, e, t);
        }
        clearSubscribers() {
            return this.#t.clearItemSubscribers(this.#e);
        }
        hasSubscribers() {
            return this.#t.hasSubscribers(this.#e);
        }
        get store() {
            return this.#t;
        }
        updateItemValue(e, t) {
            var r = this.#t.getItem(this.#e),
                s;
            C(r[e]) ? (s = { ...r[e], ...t }) : (s = t), (r[e] = s);
        }
        onHasSubscribers(e) {
            return this.#t.onHasSubscribers(this.#e, e);
        }
        onNoSubscribers(e) {
            return this.#t.onNoSubscribers(this.#e, e);
        }
    },
    _ = class {
        #e;
        #t;
        constructor(e, t, r, s = {}) {
            (this.#t = e),
                (this.#e = t),
                typeof r < "u" && this.#t.createComputedItem(this.#e, r, s);
        }
        get value() {
            return this.#t.getItem(this.#e);
        }
        get name() {
            return this.#e;
        }
        subscribe(e, t) {
            return this.#t.subscribe(this.#e, e, t);
        }
        clearSubscribers() {
            return this.#t.clearItemSubscribers(this.#e);
        }
        hasSubscribers() {
            return this.#t.hasSubscribers(this.#e);
        }
        recalc() {
            return this.#t.recalcComputed(this.#e);
        }
        get store() {
            return this.#t;
        }
        onHasSubscribers(e) {
            return this.#t.onHasSubscribers(this.#e, e);
        }
        onNoSubscribers(e) {
            return this.#t.onNoSubscribers(this.#e, e);
        }
        setCompareFunction(e) {
            return this.#t.setCompareFunction(this.#e, e);
        }
    };
var d = class {
        value;
        old_value;
        item_name;
        eventType;
        property = null;
    },
    J = /^([a-zA-Z_][a-zA-Z0-9_]*)$/,
    L = class {
        #e = new Map();
        #t = new Map();
        #s = new Map();
        #d = new Map();
        #a = null;
        #i = {};
        #n = !1;
        #o = !1;
        #h = [];
        #b = 0;
        #r = new S();
        #u = !1;
        #l = new Set();
        #p = 0;
        log = console.log;
        logError = console.error;
        warn = console.warn;
        constructor() {
            this.#r.autoRegister = !0;
        }
        #f(e) {
            return J.test(e);
        }
        #v(e, t) {
            var r = void 0,
                s = this.#e.get(e);
            s && (r = s.value);
            var i = !0;
            if (
                (this.#i[e] ? (i = this.#i[e](r, t, e, null)) : (i = A(r, t)),
                !i)
            ) {
                (s.value = t), s.version++, this.#e.set(e, s);
                let l = new d();
                return (
                    (l.eventType = "set"),
                    (l.item_name = e),
                    (l.value = t),
                    (l.old_value = r),
                    this.#c(e, l),
                    l
                );
            }
            return !1;
        }
        #_(e, t) {
            if (!this.#f(e)) throw new Error(`${e} is wrong store's item_name`);
            var r = { version: 0, value: t };
            this.#e.set(e, r);
        }
        #T(e, t, r) {
            if (this.#o)
                throw new Error(
                    "You cannot change property values \u200B\u200Bwhile reactions are running. Use method next() in reaction"
                );
            t = t.toString();
            var s = this.#s.get(e);
            let i = s.value,
                l = i[t],
                a = !0;
            if ((this.#i[e] ? (a = this.#i[e](l, r, e, t)) : (a = A(l, r)), a))
                return !1;
            i[t] = r;
            let o = new d();
            return (
                (o.eventType = "set"),
                (o.item_name = e),
                (o.property = t),
                (o.value = r),
                (o.old_value = l),
                s.version++,
                this.#c(e, o),
                o
            );
        }
        #I(e, t) {
            if (this.#o)
                throw new Error(
                    "You cannot change property values \u200B\u200Bwhile reactions are running. Use method next() in reaction"
                );
            t = t.toString();
            var r = this.#s.get(e),
                s = r.value,
                i = s[t];
            delete s[t];
            var l = new d();
            return (
                (l.eventType = "delete"),
                (l.item_name = e),
                (l.property = t),
                (l.value = null),
                (l.old_value = i),
                r.version++,
                this.#c(e, l),
                l
            );
        }
        #S(e, t) {
            Array.isArray(t) ||
                (this.warn(
                    `Cannot assign a non-array value to a collection. Now ${e} == [].`
                ),
                (t = []));
            var r = this.#s.get(e),
                s = r.value,
                i = !0,
                l = s.length;
            if (l != t.length) {
                let o = new d();
                (o.eventType = "set"),
                    (o.item_name = e),
                    (o.property = "length"),
                    (o.value = t.length),
                    (o.old_value = l),
                    r.version++,
                    this.#c(e, o);
            }
            if (s.length > t.length)
                for (let o = t.length; o < s.length; o++)
                    this.#I(e, (s.length - o - 1).toString()) && (i = !1);
            s.length = t.length;
            for (let o = 0; o < t.length; o++)
                this.#T(e, o.toString(), t[o]) && (i = !1);
            if (i) return !1;
            let a = new d();
            return (
                (a.eventType = "set"),
                (a.item_name = e),
                (a.value = t),
                (a.old_value = void 0),
                this.#c(e, a),
                this.#g([e]),
                a
            );
        }
        hasItem(e) {
            return (
                e == "store" ||
                this.#e.has(e) ||
                this.#t.has(e) ||
                this.#s.has(e)
            );
        }
        setItem(e, t) {
            var r = { [e]: t };
            this.setItems(r);
        }
        #g(e) {
            var t = G(e),
                r = new Set();
            this.#t.forEach((l) => {
                this.#$(l, t, r);
            });
            var s = this,
                i = Array.from(r).filter((l) => s.hasSubscribers(l));
            i.forEach((l) => {
                let a = s.#t.get(l);
                a.stale && s.#w(a.item_name);
            });
        }
        setItems(e) {
            if (this.#o)
                throw new Error(
                    "You cannot change property values \u200B\u200Bwhile reactions are running. Use method next() in reaction"
                );
            var t = [];
            for (let r in e) {
                if (r == "store" || this.isComputedItem(r)) continue;
                if (!this.hasItem(r)) {
                    if (this.#n) {
                        this.logError(
                            `Store is sealed. Can't create the item "${r}"`
                        );
                        continue;
                    }
                    this.#_(r, void 0);
                }
                let s = e[r],
                    i;
                this.isAtomItem(r) && (i = this.#v(r, s)),
                    this.isCollection(r) && (i = this.#S(r, s)),
                    i && t.push(r);
            }
            this.#g(t), this.#m();
        }
        isComputedItem(e) {
            return this.#t.has(e);
        }
        isAtomItem(e) {
            return this.#e.has(e);
        }
        isCollection(e) {
            return this.#s.has(e);
        }
        #A(e) {
            return e
                .map((t) => {
                    var r = this.#e.get(t) || this.#s.get(t);
                    if (r) return r.version;
                    var s = this.#t.get(t);
                    if (s) return s.stale && this.#y(s.item_name), s.version;
                })
                .join(",");
        }
        #w(e) {
            let t = this.#t.get(e);
            if (t === void 0) throw new Error(`#recalc error: ${e}`);
            let r = t.value;
            if (t.is_hard) {
                let a = t.memo,
                    o = this.#A(t.dependencies);
                if (a === o) return (t.stale = !1), !1;
                t.memo = o;
            }
            t.stale = !0;
            let s = t.getter();
            t.stale = !1;
            let i = !0;
            if (
                (this.#i[e] ? (i = this.#i[e](r, s, e, null)) : (i = A(r, s)),
                i)
            )
                return !1;
            (t.value = s), t.version++;
            let l = new d();
            return (
                (l.eventType = "set"),
                (l.item_name = e),
                (l.value = s),
                (l.old_value = r),
                this.#c(e, l),
                l
            );
        }
        recalcComputed(e) {
            if (!this.isComputedItem(e)) return !1;
            let t = this.#w(e);
            return t && this.#m(), t;
        }
        #L(e, t, r = {}) {
            let s = this;
            var i = () => {
                    try {
                        return t(s);
                    } catch (b) {
                        return (
                            this.logError(`Computed error ${e}: `, b), "#ERROR!"
                        );
                    }
                },
                l = this.getUsedItems(i),
                a = l.value,
                o = l.items,
                u = l.items.filter((b) => this.isComputedItem(b));
            if (
                (u.forEach((b) => {
                    this.#t.get(b)?.influences.add(e);
                }),
                o.length == 0)
            )
                throw new Error(`Computed item ${e} hasn't dependencies`);
            var h = r.hasOwnProperty("is_hard") ? r.is_hard : !1,
                f = "";
            h && (f = this.#A(o)),
                this.#t.set(e, {
                    item_name: e,
                    dependencies: o,
                    influences: new Set(),
                    getter: i,
                    value: a,
                    stale: !1,
                    memo: f,
                    is_hard: h,
                    version: 0,
                });
        }
        #$(e, t, r) {
            if (e.stale) return !0;
            for (
                var s = e.dependencies,
                    i = e.dependencies.filter((u) => this.#t.has(u)),
                    l = 0;
                l < s.length;
                l++
            )
                t.has(s[l]) && ((e.stale = !0), r.add(e.item_name));
            var a = this;
            function o(u) {
                u.influences.forEach((h) => {
                    let f = a.#t.get(h);
                    f &&
                        (f.stale ||
                            ((f.stale = !0),
                            r.add(h),
                            f.influences.size > 0 && o(f)));
                });
            }
            return (
                i.forEach((u) => {
                    let h = a.#t.get(u);
                    h && o(h);
                }),
                !1
            );
        }
        #k(e, t, r = !1, s = {}) {
            if (((e = e.trim()), this.hasItem(e)))
                return this.warn(`Item name ${e} name already exists`), !1;
            if (!r && !this.#f(e))
                throw new Error(`${e} is wrong store's item_name`);
            return this.#L(e, t, s), !0;
        }
        createComputedItem(e, t, r = {}) {
            return this.#n
                ? (this.logError(
                      `Store is sealed. Can't create the item "${e}"`
                  ),
                  !1)
                : this.#k(e, t, !1, r);
        }
        createCollectionItem(e, t) {
            if (((e = e.trim()), this.hasItem(e)))
                throw new Error(`Item name ${e} name already exists`);
            if (!this.#f(e)) throw new Error(`${e} is wrong store's item_name`);
            var r = this,
                s = new Proxy(t, {
                    deleteProperty: function (i, l) {
                        return (
                            i.length,
                            typeof l == "symbol"
                                ? delete i[l]
                                : typeof l == "string" &&
                                  r.#I(e, l) &&
                                  (delete i[l], r.#g([e]), r.#m()),
                            !0
                        );
                    },
                    set: function (i, l, a, o) {
                        if (typeof l == "symbol") i[l] = a;
                        else if (typeof l == "string") {
                            let u = r.#s.get(e),
                                h = u.value,
                                f = parseInt(l),
                                b = h.length;
                            if (!isNaN(f) && f >= h.length) {
                                let w = new d();
                                (w.eventType = "set"),
                                    (w.item_name = e),
                                    (w.property = "length"),
                                    (w.value = f + 1),
                                    (w.old_value = b),
                                    r.#c(e, w),
                                    u.version++;
                            }
                            r.#T(e, l, a) && ((i[l] = a), r.#g([e]), r.#m());
                        }
                        return !0;
                    },
                });
            return r.#s.set(e, { version: 0, value: t }), r.#d.set(e, s), s;
        }
        onChange(e) {
            return this.#r.on("#change", e);
        }
        onChangeAny(e, t) {
            let r = [];
            for (let l = 0; l < e.length; l++) {
                let a = e[l];
                if (typeof a == "string") {
                    this.hasItem(a) && r.push(a);
                    continue;
                }
                (a instanceof y || a instanceof _ || a instanceof E) &&
                    a.store === this &&
                    r.push(a.name);
            }
            if (r.length == 0) return;
            let s = this;
            return this.#r.on("#change", function (l) {
                let a = !1,
                    o = {};
                for (let u in l)
                    if (r.indexOf(u) > -1) {
                        (a = !0), (o[u] = l[u]);
                        break;
                    }
                a && t(o, s);
            });
        }
        deleteItem(e) {
            if (this.#n)
                return (
                    this.logError(
                        `Store is sealed. Can't delete the item "${e}"`
                    ),
                    !1
                );
            if (!this.hasItem(e)) return !1;
            let t = this.getItem(e),
                r = new d();
            return (
                (r.eventType = "delete"),
                (r.item_name = e),
                (r.value = t),
                this.clearItemSubscribers(e),
                this.isComputedItem(e) && this.#t.delete(e),
                this.isAtomItem(e) && this.#e.delete(e),
                this.isCollection(e) && (this.#s.delete(e), this.#d.delete(e)),
                this.#c(e, r),
                this.#m(),
                !0
            );
        }
        #C() {
            return Object.fromEntries(this.#e);
        }
        getItems(e = !1) {
            return e ? Object.assign({}, this.#C(), this.#x()) : this.#C();
        }
        #y(e) {
            this.#u && this.#l.add(e);
            let t = this.#t.get(e);
            if (t === void 0) throw new Error(`#getComputedValue error: ${e}`);
            t.stale && this.#w(e);
            let r = this.#t.get(e);
            if (r === void 0) throw new Error(`#getComputedValue error: ${e}`);
            return r.value;
        }
        #O(e) {
            return this.#u && this.#l.add(e), this.#d.get(e);
        }
        #x() {
            let e = {};
            return (
                this.#t.forEach((t) => {
                    e[t.item_name] = this.#y(t.item_name);
                }),
                e
            );
        }
        #N(e) {
            this.#u && this.#l.add(e);
            var t = this.#e.get(e),
                r = t ? t.value : void 0;
            return r;
        }
        getItem(e) {
            if (e == "store") return this;
            if (this.hasItem(e)) {
                if (this.isAtomItem(e)) return this.#N(e);
                if (this.isComputedItem(e)) return this.#y(e);
                if (this.isCollection(e)) return this.#O(e);
            }
        }
        getItemNames() {
            let e = [];
            return (
                this.#e.forEach((t, r) => {
                    e.push(r);
                }),
                this.#t.forEach((t, r) => {
                    e.push(r);
                }),
                this.#s.forEach((t, r) => {
                    e.push(r);
                }),
                e
            );
        }
        subscribe(e, t, r) {
            r === void 0 && (r = this.#b);
            var s = r <= 0 ? t : j(t, r);
            let i = this.#r.on(e, s);
            return (
                this.#r.getNumberOfListeners(e) == 1 &&
                    this.#r.emit("#has-subscribers:" + e, e, this),
                () => {
                    i(),
                        this.#r.getNumberOfListeners(e) == 0 &&
                            this.#r.emit("#no-subscribers:" + e, e, this);
                }
            );
        }
        hasSubscribers(e) {
            return this.#r.hasListeners(e);
        }
        clearSubscribers() {
            this.#r.unregisterAllEvents();
        }
        clearItemSubscribers(e) {
            let t = !1,
                r = this.#r.getNumberOfListeners(e);
            r != 0 &&
                (r > 0 && (t = !0),
                this.#r.removeAllListeners(e),
                t && this.#r.emit("#no-subscribers:" + e));
        }
        reset() {
            this.#e.clear(),
                this.#t.clear(),
                this.#s.clear(),
                this.clearSubscribers();
        }
        asObject() {
            return this.#a || (this.#a = this.#R()), this.#a;
        }
        #R() {
            let e = {},
                t = this,
                r = {
                    get(s, i) {
                        return typeof i == "string" ? t.getItem(i) : null;
                    },
                    set(s, i, l) {
                        return t.setItems({ [i]: l }), !0;
                    },
                    ownKeys(s) {
                        return t.getItemNames();
                    },
                    getOwnPropertyDescriptor(s) {
                        return { enumerable: !0, configurable: !0 };
                    },
                    deleteProperty: function (s, i) {
                        return typeof i == "string" && t.deleteItem(i), !0;
                    },
                };
            return new Proxy(e, r);
        }
        setCompareFunction(e, t) {
            return this.hasItem(e) ? ((this.#i[e] = t), !0) : !1;
        }
        isSealed() {
            return this.#n;
        }
        seal() {
            this.#n = !0;
        }
        unseal() {
            this.#n = !1;
        }
        #c(e, t) {
            this.#h.push([e, t]);
        }
        #m() {
            if (!this.#o) {
                this.#o = !0;
                for (var e = {}, t = 0; t < this.#h.length; ) {
                    let r = this.#h[t];
                    this.#r.emit(r[0], r[1], this),
                        t++,
                        e[r[0]] || (e[r[0]] = []),
                        e[r[0]].push(r[1]);
                }
                this.#r.emit("#change", e, this),
                    (this.#h = []),
                    (this.#o = !1),
                    this.#r.emit("#reactions_finished", this);
            }
        }
        setDebounceTime(e) {
            this.#b = e < 0 ? 0 : e;
        }
        next(e) {
            this.#o ? this.#r.once("#reactions_finished", e) : e(this);
        }
        #E() {
            for (; this.hasItem("_" + this.#p); ) this.#p++;
            return "_" + this.#p;
        }
        createAtom(e, t) {
            return typeof t > "u" && (t = this.#E()), new y(this, t, e);
        }
        createAtomItem(e, t) {
            this.setItem(e, t);
        }
        getAtom(e) {
            if (this.isAtomItem(e)) return new y(this, e, this.getItem(e));
            throw new Error(`Unknown atom ${e}`);
        }
        createComputed(e, t, r = {}) {
            return typeof t > "u" && (t = this.#E()), new _(this, t, e, r);
        }
        getComputed(e) {
            if (!this.isComputedItem(e))
                throw new Error(`Unknown computed ${e}`);
            return new _(this, e);
        }
        createCollection(e, t) {
            return typeof t > "u" && (t = this.#E()), new E(this, t, e);
        }
        getCollection(e) {
            if (this.isCollection(e)) return new E(this, e);
            throw new Error(`Unknown collection ${e}`);
        }
        observeObject(e) {
            if (!C(e))
                throw new Error(`obj must have an object type. obj = ${e}`);
            let t = this,
                r = {
                    store: {
                        get() {
                            return t;
                        },
                    },
                };
            for (let s in e) {
                let i = e[s];
                if (
                    (i instanceof Function ||
                        typeof i == "symbol" ||
                        (r[s] = {
                            get() {
                                return t.getItem(s);
                            },
                            set(l) {
                                t.setItem(s, l);
                            },
                        }),
                    this.hasItem(s))
                ) {
                    if (this.isCollection(s)) {
                        let l = Array.isArray(i) ? i : [];
                        this.#S(s, l);
                        continue;
                    }
                    if (this.isAtomItem(s)) {
                        this.#v(s, i);
                        continue;
                    }
                } else {
                    if (Array.isArray(i)) {
                        this.createCollectionItem(s, i);
                        continue;
                    }
                    if (i instanceof Function || typeof i == "symbol") continue;
                    this.#_(s, i);
                    continue;
                }
            }
            return Object.defineProperties(e, r), e;
        }
        getUsedItems(e) {
            this.#l.clear(), (this.#u = !0);
            let t = e();
            var r = Array.from(this.#l);
            return (this.#u = !1), this.#l.clear(), { value: t, items: r };
        }
        autorun(e, t = {}) {
            return this.createComputed(e, void 0, t).subscribe(() => {});
        }
        reaction(e, t, r = {}) {
            var s = this.getUsedItems(e);
            if (s.items.length > 0)
                return this.createComputed(e, void 0, r).subscribe(t);
        }
        when(e, t) {
            var r = this.getUsedItems(e);
            return t
                ? this.onChangeAny(r.items, () => {
                      try {
                          e() && t();
                      } catch (s) {
                          this.logError(s);
                      }
                  })
                : new Promise((s, i) => {
                      var l = this.onChangeAny(r.items, () => {
                          let a = e();
                          a && (l && l(), s(a));
                      });
                  });
        }
        onHasSubscribers(e, t) {
            return this.#r.on("#has-subscribers:" + e, t);
        }
        onNoSubscribers(e, t) {
            return this.#r.on("#no-subscribers:" + e, t);
        }
    };
var $ = { debounce_time: 0, autodisconnect: !1 };
function W(n, e, t, r = {}, s = {}) {
    let i = Object.assign({}, $, s),
        { debounce_time: l } = i;
    t(n, e, r, i);
    var a = n.subscribe((o) => {
        if (i.autodisconnect && !e.isConnected) {
            a();
            return;
        }
        t(n, e, r, i);
    }, l);
    return a;
}
function X(n, e, t) {
    e[t.property_name] = n.value;
}
function D(n, e, t, r = {}) {
    let s = Object.assign({}, $, r);
    return W(n, e, X, { property_name: t }, s);
}
function k(n, e, t = {}) {
    let r = Object.assign({}, $, t),
        { debounce_time: s } = r;
    function i(u) {
        e.checked = u;
    }
    var l = (u) => {
        n.value = e.checked;
    };
    i(n.value), e.addEventListener("change", l);
    var a = n.subscribe((u) => {
            if (r.autodisconnect && !e.isConnected) {
                o();
                return;
            }
            i(u.value);
        }, s),
        o = () => {
            e.removeEventListener("change", l), a();
        };
    return o;
}
function v(n, e, t = {}) {
    let r = Object.assign({}, $, { lazy: !1 }, t),
        { debounce_time: s, lazy: i } = r;
    e.type == "number" && (i = !0);
    function l(u) {
        e.value != u &&
            (e.type == "number"
                ? (e.value = parseFloat(u.toString()).toString())
                : (e.value = String(u)));
    }
    var a = j((u) => {
        let h = e.value;
        e.type == "number" ? (n.value = parseFloat(h)) : (n.value = String(h));
    }, s);
    e.addEventListener(i ? "change" : "input", a), l(n.value);
    var o = n.subscribe((u) => {
        if (r.autodisconnect && !e.isConnected) {
            o();
            return;
        }
        l(u.value);
    }, s);
    return () => {
        e.removeEventListener("input", a), o();
    };
}
var Z = "scope-ref",
    K = "$",
    Q = "ref",
    T = {
        scope_auto_name_prefix: K,
        scope_ref_attr_name: Z,
        ref_attr_name: Q,
        window: globalThis.window,
        is_scope_element: void 0,
        include_root: !1,
    },
    I = {};
function ee(n, e) {
    var t;
    return (
        e.is_scope_element
            ? (t = e.is_scope_element(n, e))
            : (t = n.getAttribute(e.scope_ref_attr_name)),
        t === null ? !1 : t
    );
}
function P(n = {}, e = !0) {
    let t = {
            scope_auto_name_prefix:
                I.scope_auto_name_prefix || T.scope_auto_name_prefix,
            scope_ref_attr_name: I.scope_ref_attr_name || T.scope_ref_attr_name,
            ref_attr_name: I.ref_attr_name || T.ref_attr_name,
            window: I.window || T.window,
            is_scope_element: I.is_scope_element || T.is_scope_element,
            include_root: I.include_root || T.include_root,
        },
        r = Object.assign({}, t, n);
    if (e && !r.window) throw new Error("options.window is not defined");
    return r;
}
function M(n, e, t) {
    var r = {};
    let s = P(t);
    function i(l) {
        let a = l.getAttribute(s.ref_attr_name);
        a && (e ? e[a] && (r[a] = l) : (r[a] = l));
    }
    return (
        s.include_root === !0 &&
            n instanceof s.window.HTMLElement &&
            (r.root = n),
        te(n, i, s),
        e && re(r, e),
        r
    );
}
function te(n, e, t) {
    let r = P(t);
    function s(a) {
        var o = a,
            u = o.parentElement;
        return u && u != n && ee(u, r) !== !1 ? 2 : 1;
    }
    let i = r.window.document.createTreeWalker(n, 1, s);
    var l;
    for (
        r.include_root === !0 && n instanceof r.window.HTMLElement && e(n);
        (l = i.nextNode());

    )
        e(l);
}
function re(n, e) {
    for (let t in e) {
        let r = n[t];
        if (!r) throw new Error(`Missing ref: ${t}`);
        let s = typeof e[t] == "function" ? e[t].prototype : e[t];
        if (s.isPrototypeOf(r) === !1)
            throw new Error(
                `The ref "${t}" must be an instance of ${s.constructor.name} (actual: ${r.constructor.name})`
            );
    }
}
function F(n, e) {
    if (typeof n != "string") throw new Error("html must be a string");
    let i = P(e).window.document.createElement("template");
    return (i.innerHTML = n), i.content;
}
function se(n) {
    document.readyState === "interactive" || document.readyState === "complete"
        ? n()
        : document.addEventListener("DOMContentLoaded", n);
}
var c = new L(),
    p = c.createAtom(""),
    g = c.createAtom(""),
    O = c.createAtom(""),
    x = c.createAtom(""),
    N = c.createAtom(""),
    R = c.createAtom(""),
    z = c.createAtom(!0),
    U = c.createAtom(!0),
    V = c.createAtom(!0),
    m = c.createComputed(() => `/tmp/${p.value}$(date +%F)`),
    ie = c.createComputed(() => `mkdir -p ${m.value}`),
    ne = c.createComputed(() => {
        let n = `7z a -p${g.value} -mhe=on "${m.value}/${p.value}$(date +%F).7z" ${R.value}`;
        return z.value ? n : "";
    }),
    le = c.createComputed(() => {
        let n = `mysqldump --default-character-set=utf8mb4 -u${x.value} -p${N.value}  ${O.value} > ${m.value}/${p.value}$(date +%F).sql && 7z a -p${g.value} -mhe=on "${m.value}/${p.value}$(date +%F).sql.7z" ${m.value}/${p.value}$(date +%F).sql && unlink ${m.value}/${p.value}$(date +%F).sql`;
        return U.value ? n : "";
    }),
    ae = c.createComputed(() => {
        let n = `7z a -p${g.value} -mhe=on "${m.value}/domains_$(date +%F).7z" /var/lib/tor/ && 7z a -p${g.value} -mhe=on "${m.value}/torrc_$(date +%F).7z" /etc/tor/torrc`;
        return V.value ? n : "";
    }),
    oe = c.createComputed(() => `cd ${m.value}`),
    ue = c.createComputed(
        () => `
# install 7zip
apt install -y p7zip-full

# backup and compress project and database
${[ie.value, ne.value, le.value, ae.value, oe.value]
    .filter((e) => e != "")
    .join(" && ")}

# remove old files
rm -rf ${m.value}

`
    );
function ce(n) {
    (p.value = n.prefix),
        (g.value = n.password),
        (O.value = n.databaseName),
        (x.value = n.databaseUsername),
        (N.value = n.databasePassword),
        (R.value = n.pathToProject);
}
function he(n, e) {
    var t = document.createElement("a");
    t.setAttribute(
        "href",
        "data:text/plain;charset=utf-8," + encodeURIComponent(e)
    ),
        t.setAttribute("download", n),
        (t.style.display = "none"),
        document.body.appendChild(t),
        t.click(),
        document.body.removeChild(t);
}
var H = F(`
    <div class="container mt-5 mb-5">
        <h1 class="display-5" style="font-size: 24px;">Actions</h1>
        <div>
            <input type="file" ref="file" hidden />
            <button class="btn btn-outline-secondary" ref="loadSettings">Load settings</button>
            <button class="ms-3 btn btn-outline-secondary" ref="saveSettings">Save settings</button>
        </div>
        <h1 class="mt-3 display-5"  style="font-size: 24px;">Archive settings</h1>
        <label class="form-label d-block">Password for archive
            <input ref="password" type="text" class="form-control" id="password" autocomplete="off" />
        </label>
        <label class="form-label d-block">Prefix for archive
            <input ref="prefix" type="text" class="form-control" id="prefix" autocomplete="off" />
        </label>


        <h1 class="mt-3 display-5"  style="font-size: 24px;">Database</h1>
        <label class="form-label d-block">Database name
            <input ref="databaseName" type="text" class="form-control" id="databaseName" autocomplete="off" />
        </label>
        <label class="form-label d-block">Database username
            <input ref="databaseUsername" type="text" class="form-control" id="databaseUsername" autocomplete="off" />
        </label>
        <label class="form-label d-block">Database password
            <input ref="databasePassword" type="text" class="form-control" id="databasePassword" autocomplete="off" />
        </label>
        <h1 class="mt-3 display-5"  style="font-size: 24px;">Pathes</h1>
        <label class="form-label d-block">Path to project
            <input ref="pathToProject" type="text" class="form-control" id="pathToProject" autocomplete="off" />
        </label>

        <div class="mt-3">
            <h1 class="mt-3 display-5 mb-2" style="font-size: 24px;">Output options</h1>
            <div class="form-check form-check-inline">
                <input type="checkbox" class="form-check-input" id="backupFiles" ref="backupFiles" autocomplete="off" />
                <label class="form-check-label" for="backupFiles">Backup files</label>
            </div>         
            <div class="form-check form-check-inline">
                <input type="checkbox" class="form-check-input" id="backupDatabase" ref="backupDatabase" autocomplete="off" />
                <label class="form-check-label" for="backupDatabase">Backup database</label>
            </div>
            <div class="form-check form-check-inline">
                <input type="checkbox" class="form-check-input" id="backupDomains" ref="backupDomains" autocomplete="off" />
                <label class="form-check-label" for="backupDomains">Backup domains</label>
            </div>
        </div>

        <h1 class="mt-3 display-5" style="font-size: 24px;">Output</h1>
        <textarea ref="output" class="form-control mt-1" id="output" rows="10" readonly></textarea>

    </div>
    <div class="pt-5"></div>    
`),
    fe = {
        prefix: HTMLInputElement,
        file: HTMLInputElement,
        loadSettings: HTMLButtonElement,
        saveSettings: HTMLButtonElement,
        password: HTMLInputElement,
        databaseName: HTMLInputElement,
        databaseUsername: HTMLInputElement,
        databasePassword: HTMLInputElement,
        pathToProject: HTMLInputElement,
        output: HTMLTextAreaElement,
        backupFiles: HTMLInputElement,
        backupDatabase: HTMLInputElement,
        backupDomains: HTMLInputElement,
    };
se(() => {
    let n = M(H, fe);
    n.loadSettings.addEventListener("click", () => {
        n.file.click();
    }),
        n.file.addEventListener("change", () => {
            if (!n.file.files || n.file.files.length === 0) return;
            let e = n.file.files[0],
                t = new FileReader();
            t.addEventListener("load", () => {
                if (!t.result || typeof t.result != "string") return;
                let r = JSON.parse(t.result);
                ce(r);
            }),
                t.readAsText(e);
        }),
        n.saveSettings.addEventListener("click", () => {
            let e = {
                prefix: p.value,
                password: g.value,
                databaseName: O.value,
                databaseUsername: x.value,
                databasePassword: N.value,
                pathToProject: R.value,
            };
            he(p.value + ".json", JSON.stringify(e, null, 2));
        }),
        v(p, n.prefix),
        v(g, n.password),
        v(O, n.databaseName),
        v(x, n.databaseUsername),
        v(N, n.databasePassword),
        v(R, n.pathToProject),
        k(z, n.backupFiles),
        k(U, n.backupDatabase),
        k(V, n.backupDomains),
        D(ue, n.output, "value", { debounce_time: 100 }),
        document.body.append(H);
});
